# Feature Update: Smart Import Depth

We have implemented "Smart Import Depth," a feature designed to enhance dependency graph analysis, tailored for Python packages and Domain-Driven Design (DDD) architectures.

### 1. Feature Overview

This function enables the generation of focused reports (e.g., "Scanner Context Only") while automatically including external dependencies (like those from a Shared Kernel) that are actively used in the code. This maintains the clarity and readability of the dependency graph.

### 2. Key Mechanisms

#### A. "Scan All, Filter View" Strategy

Instead of lazy loading, we now scan the entire project (`src`) to build a complete dependency graph. The process is as follows:
1.  All nodes not within the selected context/folder are initially hidden.
2.  An expansion algorithm is executed, which re-enables visibility for any hidden nodes that are referenced by the visible ones.

This approach ensures 100% graph accuracy and prevents broken links.

#### B. "Zero-Cost" Packages

This is a significant enhancement addressing Python's re-export pattern, where `__init__.py` files are used to create a clean public API by re-exporting symbols from sub-modules.

-   **Standard Depth (Before):** An import path like `Scanner -> Shared (__init__) -> Domain (__init__) -> Enums.py` would have a depth of 3. With a depth limit of 1, you would only see an empty `__init__.py`.

-   **Smart Depth (Now):**
    -   Traversing an `__init__.py` file (a package) has a "cost" of **0**.
    -   Traversing a regular `.py` implementation file has a "cost" of **1**.

This allows the analysis to "punch through" abstraction layers. With a depth of 1, you can now see the actual file containing the code you depend on.

#### C. Path Normalization

We have resolved inconsistencies where Python interprets an import as absolute (e.g., `dddguard.shared`), while the file system sees it as relative to the scan root (e.g., `shared`). The algorithm now dynamically removes the root directory prefix (`dddguard.`) to correctly link graph nodes.

### Example Scenario

When you run a scan on the `scanner` directory with `Depth: 1`:
1.  The system detects that `scanner/app.py` has the import `from dddguard.shared import ScopeEnum`.
2.  It traverses to `shared/__init__.py` (Cost: 0).
3.  It follows the re-export to `shared/domain/__init__.py` (Cost: 0).
4.  Finally, it discovers that `ScopeEnum` is defined in `architecture_enums.py` (Cost: 1).

**Result:** The report includes `architecture_enums.py` because the total path cost is 1.

### 3. Visualizer Update

The visualizer has been updated, and the "spectral waterfall" feature has been reimplemented to provide enhanced dependency visualization.
