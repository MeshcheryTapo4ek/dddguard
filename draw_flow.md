## План алгоритма раскладки контейнеров внутри Tower (без Row/Side)

### 0) Термины и инварианты
- Работаем только внутри одной `Tower`.
- `Zone` содержит набор `Container` верхнего уровня (дети зоны).
- `Container` — всегда прямоугольник; размеры известны на текущем уровне оптимизации.
- Координаты контейнеров не храним как “истину”: храним топологию раскладки (floorplan), координаты получаем packing-ом.
- Метрика считается по Manhattan расстоянию между контейнерами по агрегированным “стрелкам” (граф зависимостей).

---

### 1) Подготовка данных (build graph)
1. Собрать все стрелки между листьями (или между контейнерами, если уже агрегировано).
2. Построить `ContainerGraph` на уровне оптимизации:
   - Вершина: контейнер.
   - Ребро u→v с весом `w(u,v)` = кол-во стрелок между любыми листьями в поддеревьях u и v (или сумма весов).
3. Опционально: нормализовать веса (логарифм, clamp), чтобы “супер-хабы” не доминировали.

---

### 2) Bottom-up расчёт размеров контейнеров
Цель: на каждом уровне иметь фиксированные размеры прямоугольников.
1. Для каждого контейнера с листьями:
   - Упаковать листья во внутреннюю раскладку (любой простой packing: flow/grid).
   - Зафиксировать `width/height` контейнера как bounding box + padding.
2. Для каждого контейнера, у которого дети — контейнеры:
   - Повторить: сначала дети уже имеют размеры, затем упаковать детей, получить размеры родителя.
3. Дойти до уровня детей зоны: теперь все прямоугольники для оптимизации известны.

---

### 3) Представление состояния раскладки: B*-tree floorplan
1. Для набора прямоугольников (контейнеров) в рамках текущего “внешнего контейнера” (Zone или родитель):
   - Представить раскладку как B*-tree:
     - left-child: размещается справа от узла
     - right-child: размещается сверху от узла
2. Порядок обхода дерева определяет относительное соседство (контакты по сторонам).

---

### 4) Deterministic packing (получить координаты из B*-tree)
1. Выполнить contour packing:
   - Корень размещаем в (0, 0) внутри внешнего контейнера.
   - Для каждого узла:
     - если это left-child: базовый `x = parent.x + parent.w`
     - если это right-child: базовый `x = parent.x`
     - `y` выбираем минимальный возможный по “контурной линии” (skyline), чтобы не пересекаться с уже размещёнными.
2. Получаем координаты всех контейнеров без коллизий.
3. Вычисляем bounding box фактической раскладки.

---

### 5) Функция стоимости (cost)
1. Wirelength:
   - Для каждого ребра (u, v) в ContainerGraph:
     - взять центры контейнеров `(cx, cy)`
     - добавить `w(u,v) * (abs(cx_u - cx_v) + λ * abs(cy_u - cy_v))`
2. Штрафы:
   - Out-of-bounds: если раскладка вышла за границы внешнего контейнера/Zone.
   - Area inflation: штраф за слишком большой bounding box (пустоты).
   - Optional: штраф за пересечение “reserved label areas” (если есть запретные зоны).
3. Итог: `Cost = Wirelength + Penalties`.

---

### 6) Инициализация (seed layout)
1. Сгенерировать стартовую B*-tree:
   - Вариант A: случайная перестановка контейнеров.
   - Вариант B (лучше): сортировка по “центральности” (sum weights) и построение дерева так, чтобы хабы ближе к корню.
2. Запустить packing и посчитать базовый cost.

---

### 7) Локальные операции (moves) — “ездить по соседям / обходить”
На уровне B*-tree (топологии), с последующим packing:
1. `swap(a, b)`:
   - Поменять два узла местами в дереве (с сохранением поддеревьев или без — фиксировать правило).
2. `reinsert(a, new_parent, mode)`:
   - Вырезать поддерево `a` и вставить к `new_parent` как left-child или right-child (mode = RIGHT/ABOVE).
3. `mirror(subtree)`:
   - Поменять роли left/right детей внутри поддерева (эффект “обогнуть с другой стороны”).
4. `rotate(a)`:
   - Повернуть прямоугольник (если разрешено; обычно нет, но можно для “квадратных” контейнеров).
5. Ограничения:
   - Не допускать циклов/разрыва дерева.
   - Сохранять набор узлов неизменным.

---

### 8) Оптимизация: coarse-to-fine (снаружи → внутрь)
Для каждого внешнего контейнера `E` (сначала Zone, затем каждый Container рекурсивно):
1. Построить `ContainerGraph` только среди детей `E` (агрегировать стрелки внутри `E`).
2. Инициализировать B*-tree, сделать packing, посчитать cost.
3. Запустить оптимизатор:
   - Фаза 1: greedy hill-climb
     - N итераций:
       - выбрать move (случайно/эвристика по “плохим” ребрам)
       - применить move → packing → cost'
       - если cost' < cost: принять, иначе откатить
   - Фаза 2: short simulated annealing (опционально)
     - принимать ухудшения с вероятностью `exp(-(Δ)/T)`, T убывает.
4. Зафиксировать найденную раскладку детей `E`.
5. Перейти к следующему уровню: для каждого child-container повторить шаги 1–4.

---

### 9) Выходные данные
1. Для каждого контейнера на всех уровнях:
   - сохранённые относительные координаты внутри родителя
   - размеры (уже известны)
2. Для Tower:
   - координаты всех top-level в Zone, затем рекурсивно всех детей.
3. Эти координаты напрямую используются рендерером.

---

### 10) Критерии остановки и качество
- Остановка по:
  - лимиту итераций
  - отсутствию улучшений K шагов
  - достижению целевого порога cost
- Качество:
  - wirelength снизилась
  - bounding box не раздулся
  - нет выходов за границы / запретные зоны не нарушены
